differents website source :
https://www.lacl.fr/tan/asm

https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

on peu hacker ma psp avec ASSEMBLER ??

nasm -f elf64 programme_name.s -o programme_name.o : cmd for compile ur .s in object
ld programme_name.o -o programme_name : cmd to compile ur object file 

requiered on subject :
- Makefile rules $(NAME), all, clean ,fclean, bonus (only if you use bonus)
- write 64-bit assembly (Beware of "calling convention") 
- '.s' files
- compile with nasm
- use Intel synthax 

what is assembly ? :
- lowest-level programming language 
- interact directly with a computer's hardware
- works directly with processor instructions and registers (wich instructions will be translate n binary instruction for processor)

what is a register in processors/CPUs ? :
- registers are type of computer memory built directly into the processor of CPUs that is used to store an manipulate data



differents types of register on 64-bits :
- rax : general register, accumulateur, contain values and return of the functions;
- rcx : general register, loop counter;
- rdx : general register, data,  high part value of 128 bits;
- rbx : general register, base;
- rsp : general register, stack pointer;
- rbp : general register, base pointer;
- rsi : general register, source adress for shift or comparaison;
- rdi : general register, destination adress for shift or comparaison;
- r8 : general register;
- r9 : general register;
- r10 : general register;
- r11 : general register;
- r12 : general register;
- r13 : general register;
- r14 : general register;
- r15 : general register;
- rip : instruction pointer;

register RFlags : 
- contains some informations to the result and execution of the instructions

instructions of assembly :
- synthax : source instruction or destination instruction source

differents types of source operands :
- register;
- memory;
- immediate, coded values in the instruction
- implicit, values who don't appear in the instruction

differents types of destination operands :
- register
- memory

WARNING : an instruction canno't have 2 operands of type memory

operator [] ==> memory access :
[this_adress] ==> value stored in this adress
[this_register] ==> value stored in this register
we can associate one Label in [this_Label] on memory adress (use [this_Label])

data guidelines :
- allocation of memory spaces in segment data : 
    - dx ==> in .data segment ==> initialized data
    - resx ==> in .bss (block started By Symbol) ==> not initialized data
(value of x depends of the size of the data) 
x = b ==> 1 octet (byte)
x = w ==> 1 word 
x = d ==> double word
x = q ==> quadruple word
x = t ==> 10 octet



Data transfert instructions :
- mov dest, src ====>  dest <--- src;
- movzx dest, src ====> extension with 0's in dest;
- movsx dest, src ======> extension with the sign bit in dest (??? src bit or signe bit ?)
- possible sizes (user size to resolve ambiguity in instructions when necessary not in mov instruction):
    - byte : 1 octet;
    - word : 2 octet or 1 word
    - dword : 2 words
    - qword : 4 words
    - tword : 10 octet
- lea dest, [op] ===> dest <----- adress of op (Load Effective Adress)
- push op ====> decrease rsp and stack op
- pop op =====> populates in op and increase rso

Stack :
- stack is a list (Last-In First-Out): Last entered and First released
- push add data of qword (64 bits) size wich in the top of the stack
- pop remove data of qword (64 bits) sizze in the top of the stack
- rsp registre contain the adress of the data on the top of the stack
- push decrease rsp of 8
- pop increase rsp of 8

Role of the stack :
- save the register
- passing oarameeters when calling a subroutine
- storage of the local variables
- storage of the returns adress

for exemple ==>
- push qword 1 ; 1 is store in 0X0FFC, rsp is 0FFC
- push qword 2 ; 2 is store in 0X0FF4, rsp is 0FF4
- push qword 3 ; 3 is store in 0X0FEC, rsp is 0FEC

- pop rax ; RAX = 3, rsp = 0X0FF4
- pop rbx ; RBX = 2, rsp = 0X0FFC
- pop rcx ; RCX = 1, rsp = 0X1004

arithmetique instructions :
- add op1, op2 ====> op1 <--- op1 + op2
- sub op1, op2 ====> op1 <--- op1 - op2
- neg reg ====> reg <--- -reg
- inc reg ====> reg <--- reg + 1
- dec reg ====> reg <--- reg - 1
- imul op (sign or mul not sign) ====> rdx: rad <--- rax * op
- imul dest, op ====> dest <---- dest * op
- imul dest, op, immediat ====> dest <--- op * immediat
- idiv op (div not sign) ====> rax <--- rdx: rax / op /// rdx <--- rdx:rax mod op ** 2 (not forget to pu 0 (initialize) in rdx before idiv)

bits operations :
- and op1, op2 ====> op1 <--- op1 & op2
- or op1, op2 ====> op1 <--- op1 | op2
- xor op1, op2 ====> op1 <--- op1 ^ op2
- not res

comparison and connection instructions :








format:

<directive>
    <directive> <Label>
    <Label>:
        <instruction> <operand(s)>
        <instruction> <operand(s)>
        <instruction> <operand(s)>


directive global : directive for export Label (function) and use it on external files
directive section or segment :

macros (preprocesseur) : se distingue avec le caractere % (definis un therme qui sera remplacer par un autre)
exemple : %define hello 'Hello World!' ; definit un message a la string 'Hello World'
		  %assign msg_lengh 13 ; assigne une constante lenght a 13
		  %include 'ft_strlen.s' include the ft_strlen.s file on my own file

------------------------------------------------------------------------------------
VARIABLES :
tout se passe dans les section .data (pour les variables deja connues) et .bss (allocation de memoires, data unitialized)

section .data
	<Label>: d+<other> <Value>

section .bss
	<Label>: res+<other> <Value>

other = b (bytes : 8 bytes), w (word : 16 bytes), d (double-word : 32 bytes)-> float, q (quadruple-word : 64 bytes) -> double
for bigger data t -> etandue, o, y -> YMM, z -> EMM

d ou t : decimal ----> 5, 05, 0150d, 0d150 (can replace d by t)
q ou o : octal ----> 755q, 0q755 (can replace q by o)
b ou y : binary ----> 0b11011101, 0b1101_1101, 1101_1100b (can replace b by y)
h ou x : hexadecimal ---> 0xA5, 0A5x (can replace h by x)
------------------------------------------------------------------------------------


------------------------------------------------------------------------------------
CONDITIONS :

valeur signer = ex: int 
valeur non signer = ex: uint 
CMP <value1> <value2>	: comparaison de valeur numeriques 
JMP <Label>				: saut inconditionnel

JE <Label>				: effectue un saut si value1 = value2 (Jump if equal)
JNE <Label>				: effectue un saut si value1 != value2 (Jump if not equal)

JG <Label>				: effectue un saut si value1 > value2 (jump if greater) => JA pour valeur non signer 
JL <Label>				: effetue un saus si value1 < value2 (jump if lower) => JB pour valeur non signer

JGE <Label>				: effectue un saut si value1 >= value2 (jump if greater or equal) => JAE pour valeur non signer
JLE <Label>				: effetue un saus si value1 <= value2 (jump if lower or equal) => JBE pour valeur non signer

JNZ <Label>				: effectue un saut si value == 0 (jump if not zero)
JZ <Label>				: effeccut un saut si value != 0 (jump if zero)
------------------------------------------------------------------------------------

nasm -f elf64 -y ==> commande pour verifier les outils de debogage

------------------------------------------------------------------------------------
FONCTION:
===> ensemble d'instructions que l'ont peux gerer dynamiquement 
<function_name>:
	-instruction
	-instruction
	-etc.......

leaf function:
	- n'appelle pas d'autre FONCTION
	- utilise des variables locales
	- ne modifie pas la stack (RSP ou RIP) => peux seulement la lire
	-pas d'allocation dynamique
	-n'utilise pas de registre non volatile

trame function:
	- appelle d'autre fonctions
	- utilise des variables locales
	- utilise des registre volatile
	- allocation dynamique => pointeur d'images (RBP)